# C++ 基础

## 1.1 关键字

### 1.1.1 static 

在C++中，`static`关键字有多种用法和含义，下面是其中一些常见的用法：

1. 静态变量（Static Variables）：在函数内部使用`static`关键字声明的变量称为静态变量。静态变量在程序的生命周期内保持其值，而不会在每次函数调用时重新初始化。静态变量的作用域限于声明它的函数内部。

```cpp
void foo() {
    static int count = 0; // 静态变量
    count++;
    std::cout << "Count: " << count << std::endl;
}

int main() {
    foo(); // 输出 Count: 1
    foo(); // 输出 Count: 2
    foo(); // 输出 Count: 3
    return 0;
}
```

2. 静态成员变量（Static Member Variables）：在类中声明的静态变量称为静态成员变量。静态成员变量属于类本身，而不是类的实例。它被类的所有对象共享，并且可以在不创建类的实例的情况下访问。

```cpp
class MyClass {
public:
    static int count; // 静态成员变量
};

int MyClass::count = 0; // 静态成员变量的定义和初始化

int main() {
    MyClass::count++; // 访问静态成员变量
    std::cout << "Count: " << MyClass::count << std::endl;
    return 0;
}
```

3. 静态函数（Static Functions）：在类中声明的使用`static`关键字的函数称为静态函数。静态函数不操作任何特定对象，它们只能访问静态成员变量和其他静态函数。静态函数可以直接通过类名调用，而不需要创建类的实例。

```cpp
class MyClass {
public:
    static void printMessage() { // 静态函数
        std::cout << "Hello, World!" << std::endl;
    }
};

int main() {
    MyClass::printMessage(); // 调用静态函数
    return 0;
}
```

这些只是`static`关键字的一些用法，它还可以用于命名空间、局部变量以及在类中禁用某些成员的继承等方面。

### 1.1.2 const

在C++中，`const`关键字用于声明常量或指定函数的常量性。以下是`const`关键字的几种常见用法：

1. 声明常量：使用`const`关键字可以声明一个常量，即其值在程序执行期间不能被修改。

```cpp
const int MAX_VALUE = 100;
```

2. 常量引用：使用`const`关键字可以创建指向常量的引用，即引用的值不能被修改。

```cpp
int x = 10;
const int& ref = x; // 常量引用
```

3. 常量成员函数：在类中声明的成员函数可以使用`const`关键字标记为常量成员函数。常量成员函数承诺不会修改类的成员变量。

```cpp
class MyClass {
public:
    void foo() const { // 常量成员函数
        // 不能修改成员变量
        // 可以调用其他常量成员函数
    }
};
```

4. 常量对象：使用`const`关键字可以创建一个常量对象，即对象的值不能被修改。

```cpp
const MyClass obj; // 常量对象
```

5. 常量指针：使用`const`关键字可以创建指向常量的指针，即指针所指向的值不能被修改。

```cpp
int x = 10;
const int* ptr = &x; // 常量指针
```

6. 常量成员变量：在类中声明的成员变量可以使用`const`关键字标记为常量成员变量。常量成员变量必须在类的构造函数初始化列表中进行初始化。

```cpp
class MyClass {
public:
    const int MAX_VALUE; // 常量成员变量

    MyClass(int value) : MAX_VALUE(value) {}
};
```

这些是`const`关键字的一些常见用法。`const`关键字可以帮助在程序中创建和使用常量，并确保数据的不可变性。

#### 补充： const int a; const int *a; const int * const a; int *const a;  以及int const a；

```cpp
const int a; // int 类型的常量a, a 不能被修改
const int *a; // int 类型的常量指针，*a 不能被修改
int const *a; // int 类型的常量指针，*a 不能被修改
int * const a; // a 指针指向的内存地址为常量
const int * const a; // const a, 表示常量a, const int * 表示 *a 也不变。
```

#### 补充：静态局部变量、局部变量以及局部变量的特点与使用场景

在C++中，静态局部变量、全局变量和局部变量具有不同的特点和使用场景。下面是它们的特点和使用场景的概述：

1. **全局变量（Global Variables）：**
   - 全局变量是在函数外部声明的变量，其作用域涵盖整个程序。
   - 全局变量在程序启动时创建，在程序结束时销毁。
   - 全局变量可以在任何函数中访问和修改，因此具有全局可见性。
   - 全局变量的生命周期与程序的执行周期相关。
   - 全局变量适用于需要在整个程序中共享数据的场景，但过度使用全局变量可能导致命名冲突和代码维护困难。

2. **局部变量** **（Local Variables）：**
   - 局部变量是在函数或代码块内部声明的变量，其作用域限定在声明它的函数或代码块内部。
   - 局部变量在每次进入其作用域时创建，并在作用域结束时销毁。
   - 局部变量的生命周期与其所在的函数或代码块的执行周期相关。
   - 局部变量适用于需要在函数或代码块中进行临时存储和处理数据的场景。

3. **静态局部变量（Static Local Variables）：**
   - 静态局部变量是在函数或代码块内部使用`static`关键字声明的变量。
   - 静态局部变量在首次进入其作用域时创建，并在整个程序的执行周期内保持其值，直到程序退出。
   - 静态局部变量的作用域仍限定在声明它的函数或代码块内部。
   - 静态局部变量适用于需要在多次函数或代码块调用之间保持状态的场景。

下面是一个示例，展示了全局变量、局部变量和静态局部变量的使用场景：

```cpp
#include <iostream>

int globalVar = 10; // 全局变量

void foo() {
    int localVar = 5; // 局部变量
    static int staticLocalVar = 0; // 静态局部变量

    localVar++;
    staticLocalVar++;
    globalVar++;

    std::cout << "Local variable: " << localVar << std::endl;
    std::cout << "Static local variable: " << staticLocalVar << std::endl;
    std::cout << "Global variable: " << globalVar << std::endl;
}

int main() {
    foo(); // 输出 Local variable: 6, Static local variable: 1, Global variable: 11
    foo(); // 输出 Local variable: 6, Static local variable: 2, Global variable: 12
    foo(); // 输出 Local variable: 6, Static local variable: 3, Global variable: 13

    return 0;
}
```

在上述示例中，`globalVar`是一个全局变量，可以在任何函数中访问和修改。`localVar`是一个局部变量，每次调用`foo()`时都会重新创建。`staticLocalVar`是一个静态局部变量，其值在多次调用之间保持不变。

使用场景：
- 全局变量适用于需要在整个程序中共享数据的场景，但应谨慎使用，以避免命名冲突和代码维护困难。
- 局部变量适用于需要在函数或代码块中进行临时存储和处理数据的情况。
- 静态局部变量适用于需要在多次函数或代码块调用之间保持状态的情况，例如计数器、缓存等。静态局部变量还可以用于限制变量的作用域和隐藏变量，使其只在声明它的函数或代码块内可见。

### 1.1.3 define 宏函数

**宏函数（Macro Function）是一种在计算机编程中使用的宏（Macro）的形式，它允许程序员定义一段可重用的代码片段**。宏函数在预处理阶段展开，将宏的调用替换为实际的代码。宏函数的定义通常使用预处理指令（如C语言中的#define）来完成。

宏函数与普通函数的区别在于展开时机和展开方式。普通函数在编译阶段进行静态的类型检查，并生成可执行的机器代码。而宏函数在预处理阶段进行文本替换，没有类型检查，也不会生成额外的函数调用开销。

宏函数的一个常见应用是在代码中定义常量或简单的计算操作，以提高代码的可读性和维护性。例如，可以使用宏函数定义一个常量，如#define PI 3.14159，或者定义一个简单的计算操作，如#define SQUARE(x) ((x) * (x))，使得在代码中可以直接使用宏函数代替冗长的表达式。

需要注意的是，**宏函数的展开是简单的文本替换，可能会导致一些意料之外的问题**。例如，宏函数的参数可能被多次计算，或者存在副作用。因此，在使用宏函数时需要谨慎考虑展开后的代码是否符合预期，并遵循相关的最佳实践。

## 1.2 数组与指针

在C++中，数组和指针是相关但不完全相同的概念。下面是关于数组和指针的一些基本信息：

1. 数组：数组是一种数据结构，用于存储一系列相同类型的元素。在C++中，数组可以是静态数组（在编译时大小已知）或动态数组（在运行时大小可变）。数组的元素在内存中是连续存储的，可以通过索引访问。例如，下面是一个简单的整数数组的声明和使用示例：

   ````cpp
   int myArray[5]; // 声明一个静态数组，包含5个整数元素

   myArray[0] = 10; // 给数组的第一个元素赋值
   int x = myArray[2]; // 从数组中获取第三个元素的值
   ```

2. 指针：指针是一个变量，它存储另一个变量的内存地址。可以通过指针来访问存储在该地址上的值。在C++中，指针用于引用数组的元素或动态分配的内存。指针使用星号（*）进行声明和解引用操作。例如，下面是一个指向整数的指针的声明和使用示例：

   ````cpp
   int* myPointer; // 声明一个指向整数的指针

   int x = 10;
   myPointer = &x; // 将指针指向变量x的地址

   int y = *myPointer; // 解引用指针，获取存储在指针指向地址上的值
   ```

3. 数组与指针的关系：在某种程度上，数组与指针是相关的。数组名在某些情况下可以被解释为指向数组第一个元素的指针。因此，可以通过指针形式来访问数组的元素。例如，以下示例演示了数组名作为指针使用的情况：

   ````cpp
   int myArray[5] = {1, 2, 3, 4, 5};
   
   int* arrayPointer = myArray; // 数组名作为指针使用
   
   int x = *arrayPointer; // 获取数组的第一个元素
   int y = *(arrayPointer + 2); // 获取数组的第三个元素
   ```

需要注意的是，数组和指针在某些方面是不同的。例如，数组具有固定的大小，而指针可以指向不同大小的数据结构。此外，数组名不能被重新赋值，而指针变量可以改变其指向的地址。对于静态数组，数组名是常量指针，不能进行赋值操作。

在许多情况下，数组和指针可以互相转换并进行类似的操作，但在编程时需要理解它们之间的差异和使用场景。

##### 补充: `new[]` 和 `delete[]` 运算符

 **`new[]` 和 `delete[]` 运算符：除了 `new` 和 `delete` 运算符**，C++ 还提供了 `new[]` 和 `delete[]` 运算符，用于分配和释放数组类型的内存。示例代码如下：

   ````cpp
   int* arr = new int[5];  // 分配包含 5 个 int 元素的数组内存
   // ...
   delete[] arr;  // 释放数组内存
   ```
   ````

#### 补充：数组的动态联编与静态联编

数组的动态联编（Dynamic Binding）和静态联编（Static Binding）是与编程语言中的多态性（Polymorphism）相关的概念。

动态联编是指在运行时确定方法或函数的调用，根据实际的对象类型来决定使用哪个方法或函数的实现。这种联编方式通常与继承和虚函数（或者接口）相关联。在动态联编中，方法或函数的调用取决于实际对象的类型，而不是变量或表达式的声明类型。

静态联编是指在编译时确定方法或函数的调用，根据变量或表达式的声明类型来决定使用哪个方法或函数的实现。这种联编方式通常与静态类型语言相关联，其中方法或函数的调用取决于变量或表达式的静态类型。

下面以一个简单的示例来说明两者的区别：

```java
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    public void makeSound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog();  // 静态类型为Animal，实际类型为Dog
        animal.makeSound();  // 动态联编，输出"Dog barks"

        Animal animal2 = new Animal();  // 静态类型和实际类型都为Animal
        animal2.makeSound();  // 动态联编，输出"Animal makes a sound"
    }
}
```

在上面的示例中，我们创建了一个Animal类和一个继承自Animal的Dog类。在主函数中，我们分别创建了animal和animal2两个对象。

对于animal对象，我们将其静态类型声明为Animal，但实际类型为Dog。在调用`animal.makeSound()`时，会根据实际类型Dog来决定使用哪个方法的实现，因此输出的是"Dog barks"。这是动态联编的一个例子，因为方法的调用取决于实际对象的类型。

对于animal2对象，其静态类型和实际类型都为Animal。在调用`animal2.makeSound()`时，同样会根据实际类型Animal来决定使用哪个方法的实现，输出的是"Animal makes a sound"。这也是动态联编的一个例子。

需要注意的是，动态联编是在运行时确定的，而静态联编是在编译时确定的。静态联编在编译时就可以确定方法或函数的调用，因此具有更高的执行效率。而动态联编的优势在于它能够实现多态性，使得程序具有更强的灵活性和扩展性。

总结来说，动态联编和静态联编是多态性的两种实现方式，它们决定了在调用方法或函数时使用哪个实现。动态联编在运行时确定，根据实际对象的类型来决定使用哪个方法的实现；而静态联编在编译时确定，根据变量或表达式的声明类型来决定使用哪个方法的实现。

## 1.3 指针的分类与使用

1. 指针（Pointer）：指针用于存储内存地址，可以通过指针访问或修改对应地址上的数据。指针在C++中具有广泛的应用，包括动态内存分配、传递参数和操作复杂数据结构等。以下是一个示例：

```cpp
int number = 42;
int* ptr = &number;  // 声明一个指向int类型的指针，指向number的地址
cout << *ptr;       // 输出指针所指向的值，即42
*ptr = 10;          // 修改指针所指向的值
cout << number;     // 输出修改后的值，即10
```

2. 数组指针（Array Pointer）：数组指针指向数组的首元素地址，可以通过指针访问整个数组。它可以用于遍历数组、传递数组给函数等。以下是一个示例：

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* arrPtr = arr;  // 声明一个指向int类型数组的指针，指向arr的首元素地址
cout << *arrPtr;    // 输出数组的第一个元素，即1

// 遍历数组并输出所有元素
for (int i = 0; i < 5; i++) {
    cout << *(arrPtr + i) << " ";  // 输出arrPtr所指向的当前元素
}

// 通过指针修改数组元素的值
*(arrPtr + 2) = 10;  // 修改数组的第三个元素为10
cout << arr[2];     // 输出修改后的值，即10
```

3. 指针数组（Pointer Array）：指针数组是存储指针的数组，每个元素都是指向不同数据类型或对象的指针。它常用于存储不同类型的对象或动态管理对象的集合。以下是一个示例：

```cpp
int num1 = 1, num2 = 2, num3 = 3;
int* ptrArr[3] = {&num1, &num2, &num3};  // 声明一个包含3个int指针的数组，每个指针指向不同的变量

// 遍历指针数组并输出对应变量的值
for (int i = 0; i < 3; i++) {
    cout << *ptrArr[i] << " ";  // 输出指针数组中对应指针所指向的值
}
```

4. 函数指针（Function Pointer）：函数指针存储函数的地址，可以通过函数指针调用相应的函数。它常用于实现回调函数、动态选择函数等场景。以下是一个示例：

```cpp
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int main() {
    int (*funcPtr)(int, int);  // 声明一个指向接受两个int参数并返回int类型的函数的指针
    funcPtr = add;             // 将函数指针指向add函数
    cout << funcPtr(2, 3);     // 调用add函数并输出结果，即5

    funcPtr = subtract;        // 将函数指针指向subtract函数
    cout << funcPtr(5, 2);     // 调用subtract函数并输出结果，即3
}
```

5. 野指针（Wild Pointer）：野指针是指没有被初始化或者指向无效内存地址的指针。使用野指针可能导致未定义行为或崩溃。因此，应该始终将指针初始化为有效的地址，或者在不再使用指针时将其设置为nullptr。

6. this指针：this指针是一个隐含于每个非静态成员函数中的指针。它指向当前对象的地址，用于在成员函数内部访问对象的成员变量和成员函数。通过this指针，可以区分同名的成员变量和函数参数。

以下是一个示例，演示了如何使用this指针：

```cpp
class MyClass {
    int value;

public:
    void setValue(int value) {
        this->value = value;  // 使用this指针访问成员变量
    }

    int getValue() const {
        return this->value;  // 使用this指针返回成员变量的值
    }
};

int main() {
    MyClass obj;
    obj.setValue(42);
    cout << obj.getValue();  // 输出42，通过this指针访问成员变量的值
}
```

这些示例展示了不同类型的指针在C++中的使用方式和作用。理解和熟练掌握这些概念对于编写高效和灵活的C++代码非常重要。

##### 补充：野指针如何产生，如何避免？

野指针（Dangling Pointer）是指指向已释放或无效对象的指针。野指针的产生通常是由于以下情况：

1. 释放后未置空：当你释放了一个对象或者动态分配的内存块后，没有将指针设置为nullptr或另一个有效的地址，指针仍然保留之前的值。这样的指针就成为野指针。

   ````cpp
   int* ptr = new int;
   delete ptr;
   // 野指针：ptr没有被置为nullptr
   ```

2. 悬挂指针：当指针指向了一个局部变量，而该变量超出了其作用域，指针就成为野指针。

   ````cpp
   int* getPointer() {
       int value = 10;
       int* ptr = &value;
       return ptr; // 返回一个指向局部变量的指针
   }
   
   int* danglingPtr = getPointer(); // 野指针：指向已经超出作用域的局部变量
   ```

野指针的存在可能导致程序出现未定义的行为，例如访问无效的内存地址，引发访问冲突或崩溃等问题。为了避免野指针的问题，可以采取以下几种措施：

1. 初始化指针：在声明指针时，始终将其初始化为nullptr，这样可以避免使用未初始化的指针。

   ````cpp
   int* ptr = nullptr; // 初始化为nullptr
   ```

2. 及时置空指针：在释放了对象或动态分配的内存后，将指针设置为nullptr，避免产生野指针。

   ````cpp
   int* ptr = new int;
   // 使用ptr
   delete ptr;
   ptr = nullptr; // 置空指针
   ```

3. 避免悬挂指针：确保指针不指向已经超出其作用域的局部变量。

   ````cpp
   int* getPointer() {
       int* ptr = new int; // 动态分配内存
       // ...
       return ptr;
   }

   int* validPtr = getPointer(); // 合法指针
   // 使用validPtr
   delete validPtr; // 释放内存
   ```

4. 使用智能指针：C++提供了智能指针（如std::unique_ptr、std::shared_ptr等），它们可以自动管理动态分配的内存，避免手动释放和悬挂指针的问题。

   ````cpp
   #include <memory>
   
   std::unique_ptr<int> ptr = std::make_unique<int>(); // 使用智能指针
   // 使用ptr
   ```

避免野指针是良好的编程实践，可以提高程序的稳定性和安全性。在编写代码时，应始终注意指针的生命周期和有效性，并采取适当的措施来防止野指针的产生。

##### 补充： C++ 智能指针有哪些

在C++中，有几种智能指针可用于管理动态分配的内存，包括：

1. `std::unique_ptr`：`std::unique_ptr`是一种独占所有权的智能指针。它提供了对动态分配对象的独占所有权，只能有一个`std::unique_ptr`指向同一块内存。当`std::unique_ptr`超出作用域或被显式释放时，它会自动删除所管理的对象。

   ````cpp
   #include <memory>
   
   std::unique_ptr<int> ptr = std::make_unique<int>(42);
   ```

2. `std::shared_ptr`：`std::shared_ptr`是一种共享所有权的智能指针。它可以有多个`std::shared_ptr`指向相同的对象。对象的引用计数跟踪有多少个`std::shared_ptr`指向它，当引用计数变为零时，对象会被自动删除。

   ````cpp
   #include <memory>
   
   std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
   std::shared_ptr<int> ptr2 = ptr1; // 共享所有权
   ```

3. `std::weak_ptr`：`std::weak_ptr`是`std::shared_ptr`的一种弱引用。它允许访问由`std::shared_ptr`管理的对象，但不会增加引用计数。当所有`std::shared_ptr`都释放后，`std::weak_ptr`会自动失效。

   ````cpp
   #include <memory>
   
   std::shared_ptr<int> sharedPtr = std::make_shared<int>(42);
   std::weak_ptr<int> weakPtr = sharedPtr; // 弱引用
   
   if (auto shared = weakPtr.lock()) {
       // 使用shared指针访问对象
   } else {
       // 对象已经失效
   }
   ```

这些智能指针提供了自动内存管理的功能，可以避免显式地进行内存释放和悬挂指针的问题。根据需求，选择适当的智能指针可以简化内存管理，并提高代码的安全性和可读性。

## 1.4 函数

在C++中，函数可以通过参数来接受数据。参数允许在函数内部使用外部数据，并且可以将数据从调用函数传递到被调用函数。

C++函数传参有以下几种方式：

### 1.4.1 值传递（Pass by Value）

将实参的值复制给形参，函数内部对形参的修改不会影响实参。

```cpp
void func(int num) {
    num = 10;  // 修改形参的值
}

int main() {
    int value = 5;
    func(value);  // 传递实参的值给形参
    cout << value;  // 输出5，实参的值未改变
    return 0;
}
```

### 1.4.2 引用传递（Pass by Reference）

通过引用将实参绑定到形参，函数内部对形参的修改会影响实参。

```cpp
void func(int& num) {
    num = 10;  // 修改形参的值，也会修改实参的值
}

int main() {
    int value = 5;
    func(value);  // 传递实参的引用给形参
    cout << value;  // 输出10，实参的值被修改
    return 0;
}
```

### 1.4.3 指针传递（Pass by Pointer）

通过指针将实参的地址传递给形参，函数内部可以通过指针访问或修改实参的值。

```cpp
void func(int* ptr) {
    *ptr = 10;  // 通过指针修改实参的值
}

int main() {
    int value = 5;
    func(&value);  // 传递实参的地址给形参
    cout << value;  // 输出10，实参的值被修改
    return 0;
}
```

### 1.4.4 数组传递

可以将数组作为参数传递给函数，可以通过指针或引用来接受数组。

```cpp
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]);
    printArray(arr, size);  // 传递数组和数组的大小
    return 0;
}
```

此外，还可以使用默认参数，在函数定义时为参数提供默认值，使得在调用函数时可以省略对应的实参。

函数传参的选择取决于具体的需求和情况。使用值传递可以确保函数内部不会修改实参的值，而引用传递和指针传递可以在函数内部修改实参。数组传递可以用于处理数组的函数操作。根据需要选择适当的传参方式。

#### 补充：int&& num 与 int& num

##### int & num

**`int& num` 是一个引用类型的参数声明。**在这个声明中，`int&` 表示 `num` 是一个整型的引用。

引用是 C++ 中的一种特殊类型，它允许我们为一个已存在的变量创建一个别名。通过引用，我们可以使用一个名称来访问同一块内存位置上的数据，而不是创建一个新的变量。

在函数声明中，**使用引用作为参数类型可以实现引用传递，即在函数内部修改参数所引用的实际变量的值。**这意味着函数可以直接修改传递给它的参数，而这种修改将在函数调用后反映到实参上。

下面是一个使用引用参数的示例：

```cpp
void increment(int& num) {
    num++;  // 递增引用所引用的实际变量的值
}

int main() {
    int value = 5;
    increment(value);  // 传递 value 的引用给 increment 函数
    cout << value;  // 输出 6，value 的值被修改
    return 0;
}
```

在上面的示例中，`increment` 函数接受一个整型的引用参数 `num`，并将其递增。在 `main` 函数中，我们将 `value` 的引用传递给 `increment` 函数，因此 `increment` 函数可以直接修改 `value` 的值。最后，输出的结果为 6。

需要注意的是，引用参数必须初始化，并且在函数调用时，传入的实参必须与引用参数类型兼容。引用参数不能接受字面量或表达式作为实参，因为它们不是可修改的左值。

通过引用参数，可以实现在函数内部修改实参的值，避免了复制大型对象的开销，并允许函数返回多个值。引用参数在函数参数传递中具有重要的应用场景。

##### int && num (C++ 11 新特性)

**`int&& num` 是一个右值引用类型的参数声明。**在这个声明中，`int&&` 表示 `num` 是一个绑定到右值的引用。

右值引用是 C++11 引入的特性，用于表示临时对象、表达式的结果或将要销毁的对象。右值引用允许我们将一个右值绑定到一个引用上，并且可以在绑定的引用上执行一些特殊的操作，如移动语义。

在函数声明中，使用右值引用作为参数类型通常用于实现移动语义或完美转发。通过使用右值引用参数，可以有效地接受和处理右值，并在需要时进行特殊的操作。

下面是一个使用右值引用参数的示例：

```cpp
void process(int&& num) {
    // 对右值进行处理
    // ...
}

int main() {
    int value = 42;
    process(123);  // 传递一个右值给 process 函数
    process(value);  // 错误：不能将左值绑定到右值引用上
    return 0;
}
```

在上面的示例中，`process` 函数接受一个右值引用参数 `num`。在 `main` 函数中，我们可以将右值（如字面量）直接传递给 `process` 函数。但如果尝试将一个左值（如变量 `value`）传递给右值引用参数，则会引发编译错误，因为左值不能绑定到右值引用上。

右值引用参数在实现移动语义、完美转发和处理临时对象时非常有用。它们可以提高性能，并允许我们对右值进行特殊处理，如移动资源而不是进行昂贵的复制操作。

需要注意的是，右值引用参数本身是可以修改的，因为它们是左值。**如果需要在函数内部修改右值引用参数的值，可以使用 `std::move` 将其转换为右值。**

总结而言，右值引用参数允许我们接受和处理右值，并在需要时进行特殊的操作，如移动语义和完美转发。它们是 C++ 中重要的语言特性，用于优化资源管理和提高性能。

#### 补充：左值与右值

在C++中，左值（lvalue）和右值（rvalue）是用于描述表达式的两个基本概念。

1. 左值（lvalue）：左值是一个标识符，它具有一个内存地址，可以作为赋值的目标。简单来说，左值是可以放在等号左边的表达式。左值可以是变量、对象的成员、数组元素等。例如：
   - 变量：`int x = 5;`，`x` 是一个左值。
   - 对象的成员：`object.member`，`object` 是一个对象，`member` 是对象的成员，它们都是左值。
   - 数组元素：`array[0]`，`array` 是一个数组，`array[0]` 是数组的第一个元素，它是一个左值。

2. 右值（rvalue）：右值是一个临时值，它没有内存地址，不能作为赋值的目标。简单来说，右值是不能放在等号左边的表达式。右值可以是字面量、临时对象、函数返回值等。例如：
   - 字面量：`int x = 5;`，`5` 是一个右值。
   - 临时对象：`MyClass().someMethod()`，`MyClass()` 创建一个临时对象，它是一个右值。
   - 函数返回值：`int getResult() { return 42; }`，`getResult()` 函数返回一个值，它是一个右值。

C++11 引入了右值引用（rvalue reference）的概念，允许对右值进行特殊处理，如移动语义和完美转发。

右值引用的主要特点是可以绑定到右值，但不能绑定到左值。右值引用可以通过 `&&` 表示，并且可以用于实现移动构造函数、移动赋值运算符和完美转发等。

例如：
```cpp
int x = 5;  // x 是一个左值
int&& rvalueRef = 42;  // rvalueRef 是一个右值引用，绑定到右值 42
int&& anotherRef = x;  // 错误：右值引用不能绑定到左值
```

总结而言，**左值是可以放在等号左边的表达式，具有内存地址，可以作为赋值的目标；右值是临时值，没有内存地址，不能作为赋值的目标。右值引用允许对右值进行特殊处理，在移动语义和完美转发等方面发挥重要作用。**

## 1.5 内存

### 1.5.1 内存分区

在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。
- **栈**：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

- **堆**：**就是那些由 `new`分配的内存块**，他们的释放编译器不去管，由我们的应用程序去控制，一般一个`new`就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

- **自由存储区**：**就是那些由`malloc`等分配的内存块**，他和堆是十分相似的，不过它是用`free`来结束自己的生命的。

- **全局/静态存储区**：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

- **常量存储区**：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。首先，我们举一个例子：

  ```cpp
  void f() { int* p=new int[5]; }
  ```

  　　这条短短的一句话就包含了堆与栈，看到`new`，我们首先就应该想到，我们分配了一块堆内存，那么指针`p`呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针`p`。

##### 补充：new关键字 和malloc 函数 的区别

C++ 中的 `new` 运算符和 C 语言中的 `malloc` 函数都用于在堆上分配内存，但它们在语义和使用上有一些区别。

1. 语法：
   - `new` 运算符是 C++ 的关键字，使用 `new` 可以直接为对象动态分配内存并调用构造函数进行对象的初始化。例如：
     ```cpp
     int* p = new int;  // 分配一个 int 类型的内存，并初始化为默认值
     ```
   - `malloc` 函数是 C 语言提供的库函数，它只负责分配指定字节大小的内存块，不涉及对象的构造和初始化。例如：
     
     ```cpp
     int* p = (int*)malloc(sizeof(int));  // 分配一个 int 类型的内存，但不进行初始化
     ```
   
2. 类型安全：
   - **`new` 运算符是类型安全的，**它会根据所分配的类型进行内存的分配和对象的构造。它会自动计算所需的字节数，并调用相应类型的构造函数进行对象的初始化。
   - `**malloc` 函数是无类型的，它只分配指定字节数的内存块，不考虑对象的构造和初始化。**在使用 `malloc` 分配内存后，需要进行类型转换，并手动调用构造函数进行对象的初始化。

3. 内存大小：
   - `new` 运算符根据对象的类型自动计算所需的内存大小。例如，`new int` 分配的内存大小通常是 `sizeof(int)`。
   - `malloc` 函数需要手动指定所需的字节数。例如，`malloc(sizeof(int))` 分配的内存大小是 `sizeof(int)`。

4. 内存管理：
   - `new` 运算符分配的内存可以通过 `delete` 运算符释放。例如：
     ```cpp
     int* p = new int;
     // 使用 p
     delete p;  // 释放内存
     ```
   - `malloc` 函数分配的内存可以通过 `free` 函数释放。例如：
     ```cpp
     int* p = (int*)malloc(sizeof(int));
     // 使用 p
     free(p);  // 释放内存
     ```

总结而言，`new` 运算符和 `malloc` 函数都可以用于在堆上分配内存，但 `new` 运算符是 C++ 的关键字，提供了更高级的功能，包括类型安全、对象构造和初始化，以及自动计算所需内存大小。而 `malloc` 函数是 C 语言提供的库函数，它更为底层，只负责分配指定字节数的内存块。在 C++ 中通常推荐使用 `new` 运算符和 `delete` 运算符进行内存管理，除非有特殊的需求。

##### 补充：除了malloc和new，还有其他的内存分配函数吗？

除了 `malloc` 和 `new`，在 C++ 中还有其他的内存分配函数和操作符，以下是其中一些常见的：

1. **`calloc` 函数：`calloc` 函数用于在堆上分配内存，并将分配的内存初始化为零。**它接受两个参数，分别是所需的元素数量和每个元素的字节数。示例代码如下：
   
   ````c
   int* p = (int*)calloc(5, sizeof(int));  // 分配包含 5 个 int 元素的内存块，并初始化为零
   ```
   
2. **`realloc` 函数：`realloc` 函数用于重新分配已经分配的内存块的大小。**它接受两个参数，分别是指向已分配内存块的指针和新的内存块大小。`realloc` 函数可以用于扩大或缩小已分配内存的大小。示例代码如下：
   
   ````c
   int* p = (int*)malloc(sizeof(int));  // 分配一个 int 类型的内存块
   // ...
   p = (int*)realloc(p, 2 * sizeof(int));  // 扩大内存块的大小为两个 int 类型
   ```
   
3. **`new[]` 和 `delete[]` 运算符：除了 `new` 和 `delete` 运算符**，C++ 还提供了 `new[]` 和 `delete[]` 运算符，用于分配和释放数组类型的内存。示例代码如下：
   
   ````cpp
   int* arr = new int[5];  // 分配包含 5 个 int 元素的数组内存
   // ...
   delete[] arr;  // 释放数组内存
   ```
   
4. `std::allocator`：C++ 标准库提供了 `std::allocator` 类模板，它可以用于分配和释放内存。`std::allocator` 提供了 `allocate` 和 `deallocate` 成员函数来进行内存分配和释放。示例代码如下：
   ````cpp
   std::allocator<int> alloc;
   int* p = alloc.allocate(5);  // 分配包含 5 个 int 元素的内存块
   // ...
   alloc.deallocate(p, 5);  // 释放内存块
   ```

这些都是常见的内存分配函数和操作符，可以根据具体的需求选择适合的方式进行内存管理。需要注意的是，在 C++ 中应该避免混合使用不同的内存分配函数和操作符，例如在 `malloc` 分配的内存上使用 `delete` 运算符释放，或在 `new` 运算符分配的内存上使用 `free` 函数释放，这样会导致未定义的行为。

### 1.5.2 各个变量生命周期

在 C++ 中，变量可以分为以下几个类型：

1. 自动变量（Automatic Variables）：自动变量是在程序的块（函数、循环等）内部声明的变量。它们的生命周期与其所在块的执行周期相对应。当块的执行结束时，自动变量会自动被销毁。

   ````cpp
   void myFunction() {
       int x = 10; // 自动变量
       // ...
   }
   ```

2. 静态变量（Static Variables）：静态变量是在函数内部使用 `static` 关键字声明的变量，也可以是在全局作用域中声明的变量。静态变量在程序的整个执行过程中存在，并且只会被初始化一次。

   ````cpp
   void myFunction() {
       static int counter = 0; // 静态变量，只会初始化一次
       // ...
   }
   ```

3. 动态变量（Dynamic Variables）：动态变量是通过动态内存分配（如 `new` 操作符）创建的变量。它们的生命周期由程序员显式管理。动态变量在使用后需要手动释放内存，否则可能导致资源泄漏。

   ````cpp
   void myFunction() {
       int* dynamicVar = new int; // 动态变量
       // 使用 dynamicVar
       delete dynamicVar; // 释放内存
   }
   ```

4. 全局变量（Global Variables）：全局变量是在所有函数之外声明的变量，它们在整个程序的执行过程中存在。全局变量在程序启动时创建，并在程序结束时销毁。

   ````cpp
   int globalVar = 10; // 全局变量

   int main() {
       // ...
   }
   ```

5. 静态全局变量（Static Global Variables）：静态全局变量是在全局作用域中使用 `static` 关键字声明的变量。它们的作用域仅限于当前文件，并且在整个程序的执行过程中存在。

   ````cpp
   static int staticGlobalVar = 10; // 静态全局变量
   
   int main() {
       // ...
   }
   ```

了解不同类型变量的生命周期对于正确地管理内存和避免悬挂指针等问题非常重要。根据需求，选择适当的变量类型可以确保变量在正确的时间段内存在，并在不再需要时进行适当的清理。

关于初始化的时机，不同类型的变量有不同的规则：

1. 自动变量和静态变量：自动变量和静态变量的初始化可以在声明时进行，也可以在运行时进行。对于自动变量，如果声明时没有显式初始化，它们的值将是未定义的（除非是内置类型的自动变量，这种情况下将具有随机值）。静态变量在首次进入其作用域时初始化，如果没有显式初始化，则会被默认初始化为零或空。

2. 动态变量：动态变量的初始化是通过调用构造函数来完成的。使用 `new` 运算符创建的动态变量会自动调用相应类型的构造函数进行初始化。如果类型没有定义构造函数，则会按照默认规则进行初始化（例如，内置类型会被默认初始化为零）。

3. 全局变量：全局变量的初始化在程序开始之前进行，它们会在任何函数执行之前进行初始化。如果没有显式初始化，全局变量将被默认初始化为零或空。

需要注意的是，C++ 有一些特殊情况和语法规则，例如静态成员变量、常量表达式、构造函数的成员初始化列表等，它们会影响变量的初始化时机和方式。

当涉及到更复杂的情况时，C++ 中的变量初始化有一些特殊的规则和语法：

1. 静态成员变量（Static Member Variables）：静态成员变量是类的成员变量，它们与类的实例无关，而是与整个类相关联。**静态成员变量必须在类外部进行定义，并且在类外部初始化。**它们的初始化只会在程序的第一次使用之前进行。

2. 常量表达式（Constant Expressions）：常量表达式是在编译时可以被完全求值的表达式。在 C++11 及以后的标准中，常量表达式可以用于初始化静态变量和数组的大小。常量表达式的求值发生在程序运行之前。

3. 构造函数的成员初始化列表（Constructor Member Initialization List）：在类的构造函数中，可以使用成员初始化列表来初始化成员变量。成员初始化列表位于构造函数的定义中，在构造函数的主体之前执行。使用成员初始化列表可以避免在构造函数的主体中对成员变量进行赋值操作，而是直接通过初始化列表将值传递给成员变量。

以下是一个示例代码，展示了上述情况的使用：

```cpp
class MyClass {
public:
    static int staticVar;         // 静态成员变量声明
    int normalVar;                // 普通成员变量
    MyClass(int val) : normalVar(val) {
        // 构造函数的成员初始化列表
    }
};

int MyClass::staticVar = 10;      // 静态成员变量定义和初始化

int main() {
    MyClass obj(5);               // 创建对象时调用构造函数进行初始化
    return 0;
}
```

在上述示例中，`staticVar` 是一个静态成员变量，在类外部进行了定义和初始化。`normalVar` 是一个普通成员变量，通过构造函数的成员初始化列表进行了初始化。当创建 `MyClass` 对象时，构造函数会被调用，其中的成员初始化列表会在构造函数的主体之前执行，从而初始化成员变量。

总结起来，C++ 中变量的初始化时机和方式根据变量的类型、作用域、声明位置以及特殊语法规则而有所不同。了解这些规则有助于正确地初始化变量并避免未定义的行为。

##### 补充： 堆与栈的区别

堆和栈还有几点不同：

###### 1、申请后系统的响应

栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

###### 2、申请大小的限制

栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。

堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

###### 3、申请效率的比较：

栈由系统自动分配，速度较快。但程序员是无法控制的。

堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。
另外，在WINDOWS下，**最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一块内存**，虽然用起来最不方便。但是速度快，也最灵活。

###### 4、堆和栈中的存储内容

栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

###### 5、堆和栈上的内存操作越界

1. 堆内存越界主要是操作的内存超过了calloc/malloc/new等在堆上分配内存函数所分配的大小，后果导致下次calloc/malloc/new的失败，malloc失败发生_int_malloc错误（引起abort）大多是这种情况引起的；

2. 栈内存越界的情况大多出现在对数组的操作上，数组下标超过了数组定义的长度，后果导致覆盖其他变量。

### 1.5.3 内存管理

![img](.\image\0e6564ab73619c5e328a36eae9f9a3d8.png)

在典型的可执行程序中，常见的几个主要的section有：

1. **文本段（Text Segment 或 Code Segment）**：文本段是存放程序的机器指令的部分，也就是可执行代码。它通常是只读的，包含程序的指令和常量数据。文本段在程序运行时被加载到内存中，并且是共享的，多个进程可以共享同一个可执行文件的文本段。

2. **数据段（Data Segment 或 Initialized Data Segment）**：数据段存放已经初始化的全局变量和静态变量。这些变量的初始值在编译时就已经确定，并且它们在程序整个运行过程中保持不变。数据段通常是读写的。

3. **BSS段（Block Started by Symbol）**：BSS段存放未初始化的全局变量和静态变量。这些变量在编译时被分配了内存空间，但其初始值为0或空指针，因此在可执行文件中不存储具体的初始值。在程序加载时，BSS段中的变量会被初始化为0或空指针。BSS段通常是读写的。

4. **堆（Heap）**：堆是用于动态分配内存的区域。程序在运行时可以通过堆来申请和释放内存。堆的大小并不固定，可以根据需要进行动态扩展或收缩。堆的管理通常由程序员手动控制，通过调用`new`和`delete`（或`malloc`和`free`）等函数来进行内存的分配和释放。

5. **栈（Stack）**：栈是用于存储函数调用和局部变量的区域。每当函数被调用时，栈都会分配一块内存用于保存函数的局部变量和临时数据。函数调用结束后，栈会自动释放这些内存。栈的大小在程序运行时是固定的，由编译器在编译时决定。

程序启动的过程可以概括为以下几个步骤：

1. 加载：操作系统将可执行文件从磁盘加载到内存中。加载过程中，操作系统会为程序分配内存空间，并将可执行文件的各个section加载到相应的内存区域。

2. 入口点：执行从操作系统加载的代码开始执行。在大多数操作系统中，程序的入口点是一个特定的函数，通常是C/C++中的`main`函数。

3. 初始化：在进入`main`函数之前，操作系统会自动进行一些初始化工作，例如设置环境变量、处理命令行参数等。

4. 运行：程序开始执行`main`函数中的代码。从`main`函数开始，程序按照代码中定义的逻辑执行各种操作，包括函数调用、变量操作等。

5. 退出：当`main`函数执行完毕或通过调用`exit`函数显式地退出时，程序将进行清理工作，例如关闭文件、释放动态分配的内存等。然后将控制权返回给操作系统。

注意，以上是一个简化的程序启动过程描述，实际的启动过程可能因操作系统和编译器的不同而有所差异。

在C++中，静态区（Static Storage Area）是指用于存储静态变量、全局变量和静态类成员变量的区域。静态区在程序的整个运行过程中都存在，并且存储的数据在程序生命周期内保持不变。

#### 静态区 = BSS (Block Started by Symbol) + DS（data Segment）

静态区包括两个部分：

1. 数据段（Data Segment）：数据段用于存储已经初始化的全局变量、静态变量和静态类成员变量。这些变量在编译时就已经确定其初始值，并且在程序运行期间保持不变。数据段通常具有读写权限。

2. BSS段（Block Started by Symbol）：BSS段用于存储未初始化的全局变量、静态变量和静态类成员变量。这些变量在编译时被分配了内存空间，但其初始值为零或空指针，在程序加载时会被初始化为零值。BSS段通常具有读写权限。

静态区的管理通常由编译器和链接器自动处理，程序员无需显式地操作静态区的分配和释放。静态区中的变量在程序启动时被分配内存，在程序退出时释放内存。

需要注意的是，静态区中的变量可以被整个程序访问，因此应谨慎使用全局变量和静态变量，避免命名冲突和不必要的全局状态共享。

#### BSS 段

在C++中，BSS段（Block Started by Symbol）用于存储未初始化的全局变量和静态变量。这些变量在编译时被分配了内存空间，但其初始值为零或空指针，因此在可执行文件中不存储具体的初始值。在程序加载时，BSS段中的变量会被初始化为零或空指针。

BSS段的主要特点包括：

1. 存储未初始化的变量：BSS段用于存储编译器中声明的未初始化的全局变量和静态变量。例如，以下代码中的变量`myGlobalVar`和`myStaticVar`将被分配到BSS段：

   ````cpp
   int myGlobalVar;
   static int myStaticVar;
   ```

2. 初始值为零或空指针：BSS段中的变量在加载时会被初始化为零值或空指针。因此，BSS段中的变量在程序启动时具有相同的初始值。

3. 节省存储空间：由于BSS段中的变量没有具体的初始值存储，而仅仅需要记录变量的大小和位置，因此可以节省可执行文件的存储空间。

需要注意的是，只有未初始化的全局变量和静态变量才会被分配到BSS段。已经初始化的全局变量和静态变量将被分配到数据段（Data Segment）中。

BSS段的名称来自于早期汇编语言的一个指令，用于指示将一块内存清零并分配给多个变量。在现代编译器中，BSS段通常由编译器和链接器自动处理，程序员无需显式地操作BSS段。

#### 数据段

在C++中，数据段（Data Segment）用于存储已经初始化的全局变量和静态变量。这些变量在编译时就已经确定其初始值，并且在程序整个运行过程中保持不变。

数据段的特点包括：

1. 存储已初始化的变量：数据段用于存储编译器中声明的已经初始化的全局变量和静态变量。例如，以下代码中的变量`myGlobalVar`和`myStaticVar`将被分配到数据段：

   ````cpp
   int myGlobalVar = 10;
   static int myStaticVar = 20;
   ```

2. 具有初始值：数据段中的变量在编译时就已经确定其初始值，并且在程序运行期间保持不变。这些初始值可以是常量、字面值或者其他变量的值。

3. 读写权限：数据段中的变量通常具有读写权限，可以在程序运行时对其进行读取和修改操作。

与数据段相对应的是BSS段（Block Started by Symbol），BSS段用于存储未初始化的全局变量和静态变量。这些变量在编译时被分配了内存空间，但其初始值为零或空指针，在程序加载时会被初始化为零值。

需要注意的是，局部变量（函数中声明的变量）通常是存储在栈（Stack）中而不是数据段中。栈上的局部变量在函数调用时动态分配，并在函数退出时自动释放。

数据段的管理通常由编译器和链接器自动处理，程序员无需显式地操作数据段的分配和释放。

### 1.5.4 内存对齐

在C++中，结构体（struct）、类（class）和联合体（union）在内存中存储时，可能会受到数据对齐的影响。数据对齐是指将数据存储在内存中时按照特定规则对数据进行对齐操作，以提高内存访问效率。

数据对齐的规则是由编译器和平台决定的，可能因编译器、编译选项和目标平台而异。常见的对齐规则包括：

1. 成员对齐：结构体和类中的成员变量通常会按照其类型进行对齐。例如，一个int类型的成员变量通常会按照4字节对齐。对齐规则可以通过编译器的特定选项进行设置或者通过特定的关键字（如`#pragma pack`）进行控制。

2. 默认对齐：结构体和类的默认对齐值是编译器和平台相关的。通常情况下，对齐值是结构体或类中成员变量的最大对齐要求。例如，如果结构体中包含一个double类型的成员变量（通常需要8字节对齐），则结构体的默认对齐值可能为8字节。

3. 手动对齐控制：在某些情况下，程序员可以使用特定的语法或属性来手动控制数据的对齐方式。例如，C++11引入了`alignas`关键字，允许程序员指定变量或类型的对齐方式。

对齐的主要目的是优化内存访问速度和硬件对齐要求。通过对齐，可以减少内存访问的次数和处理器对于未对齐数据的额外开销。

需要注意的是，不同的对齐规则可能会导致结构体或类的大小增加（因为会插入额外的填充字节），从而影响内存的消耗和数据布局。此外，对齐规则可能因编译器和目标平台的不同而有所变化，因此在编写跨平台代码时应注意对齐的影响和可移植性。

## 2.1 C++  新特性

#### 2.1.1 统一初始化方法

在C++11中，引入了一种称为统一初始化（uniform initialization）的新特性，它提供了一种统一的语法来初始化各种类型的对象，包括内置类型、自定义类型和STL容器等。统一初始化方法可以通过以下几种方式来使用：

1. 列表初始化（List Initialization）：使用花括号（{}）来初始化对象。例如：

   ````cpp
   int x = {10};
   std::vector<int> vec = {1, 2, 3};
   ```

   这种方式可以用于初始化数组、结构体、类等各种类型的对象。

2. 拷贝初始化（Copy Initialization）：使用等号（=）来初始化对象。例如：

   ````cpp
   int x = 10;
   std::string str = "Hello";
   ```

   这种方式可以用于初始化大多数类型的对象。

3. 直接初始化（Direct Initialization）：使用圆括号（()）来初始化对象。例如：

   ````cpp
   int x(10);
   std::string str("Hello");
   ```

   这种方式可以用于初始化大多数类型的对象，与拷贝初始化相比，直接初始化更加直观。

4. 默认初始化（Default Initialization）：可以不显式提供初始化值，对象将被默认初始化。例如：

   ````cpp
   int x{};  // x被默认初始化为0
   std::string str{};  // str被默认初始化为空字符串
   ```
   
   这种方式适用于内置类型和类类型。

使用统一初始化方法可以简化代码并提高可读性，它还可以防止某些类型的隐式类型转换和缩窄转换，提供更严格的类型检查。

#### 2.1.2 成员变量默认初始化

在C++11中，引入了一项新特性，允许在类的定义中为成员变量提供默认初始化值。这个特性主要通过使用成员初始化列表（member initialization list）来实现。在类的定义中，可以在构造函数的定义之前使用冒号（:）来指定成员变量的默认初始化值。语法如下：

```cpp
class MyClass {
public:
    // 构造函数
    MyClass() : memberVariable(defaultValue) {
        // 构造函数的其他代码
    }

    // 类的其他成员函数

private:
    // 成员变量
    DataType memberVariable = defaultValue;
};
```

在上面的代码中，`memberVariable` 是一个成员变量，`defaultValue` 是它的默认初始化值。通过在构造函数的定义之前使用冒号和成员初始化列表，可以将 `memberVariable` 初始化为 `defaultValue`。

注意，在C++11之前，**如果要为成员变量提供默认初始化值，通常需要在每个构造函数中手动赋值。而在C++11中，可以通过成员初始化列表只在一个地方指定默认初始化值，从而简化了代码**。

值得一提的是，如果成员变量使用了默认的构造函数进行初始化，则不需要显式提供默认初始化值。例如，对于内置类型的成员变量，如果没有提供默认初始化值，它们将被默认初始化为零或空值，具体取决于类型。

这个新特性使得在定义类时为成员变量提供默认值变得更加方便和直观，同时也提高了代码的可读性和可维护性。

#### 2.1.3 auto 关键字

在C++11中，引入了一个新的关键字 `auto`，用于自动类型推导。`auto` 关键字的作用是让编译器根据变量的初始化表达式来推导出变量的类型，从而简化类型声明的过程。使用 `auto` 关键字的语法如下：

```cpp
auto variable = initializer;
```

其中，`variable` 是待声明的变量，`initializer` 是变量的初始化表达式。编译器会根据 `initializer` 推导出 `variable` 的类型，并自动将其替换为相应的类型。例如：

```cpp
auto x = 10;  // 推导出 x 的类型为 int
auto str = "Hello";  // 推导出 str 的类型为 const char*
auto vec = std::vector<int>();  // 推导出 vec 的类型为 std::vector<int>
```

使用 `auto` 关键字可以简化代码，特别是在使用模板和复杂类型时，可以避免显式指定类型名称，使代码更加清晰和易于维护。此外**，`auto` 关键字还可以与范围循环（range-based for loop）等语言特性结合使用，进一步简化代码编写。需要注意的是，`auto` 推导的类型是静态类型，在变量初始化时确定，并在后续使用过程中保持不变。如果初始化表达式是引用类型，`auto` 推导会保留引用性质。**另外，C++14 进一步扩展了 `auto` 的功能，引入了 `decltype(auto)`，用于推导变量的类型，包括引用类型和表达式的返回类型。这使得类型推导更加灵活和准确。

#### 2.1.4 decltype 求表达式类型

在C++11中引入的 `decltype` 关键字用于获取表达式的类型。`decltype` 关键字接受一个表达式作为参数，并返回该表达式的静态类型。

`decltype` 的语法如下：

```cpp
decltype(expression)
```

其中，`expression` 是要求值的表达式。`decltype` 将返回该表达式的类型。

例如：

```cpp
int x = 10;
decltype(x) y;  // y 的类型为 int

const double& foo();
decltype(foo()) z;  // z 的类型为 const double&
```

在上面的例子中，`decltype(x)` 返回 `int` 类型，因为 `x` 是一个 `int` 变量。而 `decltype(foo())` 返回 `const double&` 类型，因为 `foo()` 表达式的返回类型是 `const double&`。

`decltype` 对于模板编程和泛型编程非常有用，可以根据表达式的类型进行类型推导，避免显式指定类型，提高代码的通用性和可复用性。

需要注意的是，`decltype` 处理表达式时，会保留常量修饰符和引用修饰符。如果表达式是一个变量，`decltype` 返回该变量的类型。如果表达式是一个函数调用，`decltype` 返回函数调用的返回类型。如果表达式是一个左值，`decltype` 返回该左值的引用类型。

另外，在 C++14 中引入了 `decltype(auto)`，它可以用于推导包括引用类型和表达式返回类型在内的更复杂类型。

#### 2.1.5 智能指针 shared_ptr 

`shared_ptr` 是 C++ 标准库提供的智能指针之一，用于管理动态分配的对象。它允许多个 `shared_ptr` 共享同一个对象的所有权，通过引用计数的方式自动跟踪和释放对象。

使用 `shared_ptr` 需要包含 `<memory>` 头文件。以下是 `shared_ptr` 的基本用法：

```cpp
#include <memory>

// 创建 shared_ptr，并初始化为动态分配的对象
std::shared_ptr<int> ptr1(new int(10));

// 通过 make_shared 创建 shared_ptr
std::shared_ptr<int> ptr2 = std::make_shared<int>(20);

// 通过拷贝构造函数创建 shared_ptr
std::shared_ptr<int> ptr3 = ptr1;

// 使用 shared_ptr 访问对象
int value = *ptr1;

// 使用 shared_ptr 重置指向的对象
ptr1.reset(new int(30));

// 获取当前引用计数
int count = ptr1.use_count();
```

在上述代码中，`shared_ptr` 的构造函数接受一个指向动态分配对象的原始指针，并创建一个 `shared_ptr` 对象来管理该对象。当所有指向该对象的 `shared_ptr` 超出作用域或被显式释放时，引用计数会减少，如果引用计数为零，则会自动释放对象。

使用 `make_shared` 函数可以更方便地创建 `shared_ptr`，它在动态分配对象的同时还分配了一个引用计数对象，可以减少内存开销和提高性能。

通过拷贝构造函数或赋值运算符，可以创建多个指向同一个对象的 `shared_ptr`，它们共享对象的所有权。只有当最后一个 `shared_ptr` 被销毁时，引用计数为零，对象才会被自动释放。

可以通过 `*` 运算符解引用 `shared_ptr` 来访问对象，也可以使用 `->` 运算符访问对象的成员函数和成员变量。

`reset` 函数可以将 `shared_ptr` 重置为指向另一个对象，同时引用计数减少。

`use_count` 函数可以获取当前 `shared_ptr` 的引用计数。

使用 `shared_ptr` 可以避免手动管理动态分配对象的内存释放，从而提高代码的安全性和可靠性。然而，需要避免循环引用（两个或多个 `shared_ptr` 相互引用），以避免内存泄漏。在需要共享对象所有权的情况下，`shared_ptr` 提供了一种方便且相对安全的管理方式。

#### 2.1.6 空指针 nullptr 

在 C++11 中引入了空指针常量 `nullptr`，用于表示空指针值。

在传统的 C++ 中，通常使用整数常量 0 来表示空指针。然而，这种方式可能会引起一些潜在的问题，因为整数类型和指针类型可以相互隐式转换，导致一些意外的行为和错误。

`nullptr` 是一个关键字，用于明确表示空指针，它是一个字面量常量。使用 `nullptr` 可以提高代码的可读性和类型安全性。

以下是使用 `nullptr` 的示例：

```cpp
int* ptr1 = nullptr;  // 初始化指针为 nullptr
int* ptr2 = NULL;     // 传统方式，但不推荐使用

if (ptr1 == nullptr) {
    // 检查指针是否为空
}

if (ptr2 == nullptr) {
    // 检查指针是否为空
}

void foo(int* ptr) {
    // 函数参数可以接受 nullptr
    if (ptr == nullptr) {
        // 处理空指针情况
    }
}

```

在上述示例中，`ptr1` 是一个指向 `int` 类型的指针，初始化为 `nullptr`。`ptr2` 是使用传统方式将指针初始化为 `NULL`，但推荐使用 `nullptr`。

在条件语句中，可以使用 `==` 运算符将指针与 `nullptr` 进行比较，以检查指针是否为空。

`nullptr` 可以作为函数参数，用于接受空指针。

使用 `nullptr` 可以避免因为整数和指针的隐式转换而引发的潜在问题，提高代码的可读性和类型安全性。推荐在 C++11 及以上的版本中使用 `nullptr` 来表示空指针。

#### 2.1.7 for 循环

在 C++11 中，引入了一种更加简洁和灵活的 `for` 循环语法，称为范围-based `for` 循环或简称为范围 `for` 循环（Range-based for loop）。

范围 `for` 循环用于遍历容器（如数组、向量、列表等）或其他支持迭代器的对象的元素，而不需要显式使用索引或迭代器。

范围 `for` 循环的基本语法如下：

```cpp
for (declaration : range) {
    // 循环体
}
```

其中：

- `declaration` 是一个声明，用于定义一个变量，该变量将在每次迭代中接收容器中的元素。

- `range` 是要遍历的容器或支持迭代器的对象，它表示要遍历的范围。

在每次循环迭代中，范围 `for` 循环将会自动迭代 `range` 中的元素，并将每个元素赋值给 `declaration` 声明的变量，然后执行循环体。

以下是使用范围 `for` 循环的示例：

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};

for (int number : numbers) {
    std::cout << number << " ";
}

// 输出：1 2 3 4 5
```

在上述示例中，`numbers` 是一个包含整数的向量容器。使用范围 `for` 循环，每次迭代将会将容器中的元素赋值给 `number` 变量，并将其输出到控制台。

范围 `for` 循环可以简化遍历容器的代码，并提高代码的可读性。它适用于大多数需要遍历容器元素的情况，而不需要手动管理迭代器或索引。

#### 2.1.8 右值引用

在 C++11 中引入了一项重要的特性，即右值引用（Rvalue reference）。右值引用允许我们对临时对象（右值）进行引用绑定，并且可以通过移动语义来高效地管理资源。

右值引用的声明使用双 && 符号，例如 `T&&`，其中 `T` 是类型名称。通过使用右值引用，可以实现移动语义和完美转发（Perfect Forwarding）。

以下是右值引用的一些常见用法和特性：

1. 移动语义（Move Semantics）：通过右值引用，可以将资源从一个对象转移到另一个对象，而不是进行深拷贝。这可以显著提高性能，尤其是对于大型对象或资源密集型操作。

2. 移动构造函数（Move Constructor）和移动赋值运算符（Move Assignment Operator）：通过定义移动构造函数和移动赋值运算符，可以实现对资源的高效移动。移动构造函数和移动赋值运算符接受右值引用参数，并从源对象中“窃取”资源。

3. std::move：`std::move` 是一个标准库函数，用于将左值转换为右值引用。它表示我们正在放弃对对象的所有权，并且可以启用移动语义。

4. 完美转发（Perfect Forwarding）：通过使用右值引用和模板，可以实现参数的完美转发，将函数调用中的参数传递给其他函数，同时保留参数的值类别（左值或右值）和常量性。

以下是一个使用右值引用和移动语义的示例：

```cpp
class Resource {
    // Resource 的定义
};

class MyClass {
public:
    MyClass(Resource&& resource) : resource_(std::move(resource)) {
        // 移动构造函数
    }

    MyClass& operator=(Resource&& resource) {
        resource_ = std::move(resource);
        // 移动赋值运算符
        return *this;
    }

private:
    Resource resource_;
};

int main() {
    Resource r1; // 创建 Resource 对象
    MyClass obj1(std::move(r1)); // 使用移动构造函数

    Resource r2; // 创建 Resource 对象
    MyClass obj2(Resource()); // 使用移动构造函数（临时对象）

    Resource r3; // 创建 Resource 对象
    MyClass obj3 = std::move(r3); // 使用移动赋值运算符

    return 0;
}
```

在上述示例中，`Resource` 是一个表示某种资源的类。`MyClass` 类具有移动构造函数和移动赋值运算符，它们接受右值引用参数，并使用 `std::move` 来实现对 `resource_` 成员的移动。

在 `main()` 函数中，我们创建了几个 `Resource` 对象，并使用右值引用将它们移动到 `MyClass` 对象中。

右值引用和移动语义提供了一种高效且安全的资源管理方式，特别适用于大型对象或资源密集型操作。它们是现代 C++ 中重要的特性，可以提高代码的性能和可读性。

#### 2.1.9 无序容器

在 C++11 中，引入了一种称为无序容器（Unordered Containers）的数据结构，用于存储和管理一组元素。无序容器提供了高效的查找、插入和删除操作，其内部实现基于哈希表（Hash Table）。

C++11 提供了四种无序容器：

1. `std::unordered_set`：无序唯一元素集合，不允许重复。

2. `std::unordered_multiset`：无序元素集合，允许重复。

3. `std::unordered_map`：无序键值对集合，根据键进行快速查找。

4. `std::unordered_multimap`：无序键值对集合，允许键重复。

这些无序容器的用法类似于其有序（有序容器）对应物（`std::set`、`std::multiset`、`std::map`、`std::multimap`），但无序容器不维护元素的顺序，而是利用哈希函数将元素分散存储在内部的桶中。

以下是使用无序容器的示例：

```cpp
#include <iostream>
#include <unordered_set>
#include <unordered_map>

int main() {
    // 使用无序集合（unordered_set）
    std::unordered_set<int> set = {4, 2, 6, 1, 3, 5};

    for (int num : set) {
        std::cout << num << " ";
    }
    // 输出：1 2 3 4 5 6

    std::cout << std::endl;

    // 使用无序映射（unordered_map）
    std::unordered_map<std::string, int> map = {
        {"apple", 5},
        {"banana", 10},
        {"orange", 3}
    };

    for (const auto& pair : map) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
    /*
    输出：
    apple: 5
    banana: 10
    orange: 3
    */

    return 0;
}
```

在上述示例中，我们使用了 `std::unordered_set` 存储一组整数，并使用范围 `for` 循环遍历打印每个元素。然后，我们使用 `std::unordered_map` 存储水果名称与对应的数量，并使用范围 `for` 循环遍历打印每个键值对。

无序容器提供了快速的查找、插入和删除操作，其性能通常比有序容器更高效。然而，无序容器不会保持元素的顺序，因此如果需要有序性，应该使用有序容器。

#### 2.1.10 正则表达式

在 C++11 中，引入了对正则表达式的支持，通过 `<regex>` 头文件提供了一组类和函数来进行正则表达式的匹配和处理。

以下是使用 C++11 正则表达式的基本步骤：

1. 包含 `<regex>` 头文件：`#include <regex>`

2. 创建一个 `std::regex` 对象，表示要匹配的正则表达式模式。

3. 使用正则表达式进行匹配，可以使用 `std::regex_match`、`std::regex_search` 等函数。

4. 使用正则表达式进行替换，可以使用 `std::regex_replace` 函数。

下面是一个示例，展示了如何使用正则表达式匹配和替换字符串：

```cpp
#include <iostream>
#include <regex>

int main() {
    std::string text = "Hello, 2021!";

    // 匹配整个字符串是否符合正则表达式模式
    std::regex pattern("Hello, \\d{4}!");

    if (std::regex_match(text, pattern)) {
        std::cout << "Match found!" << std::endl;
    } else {
        std::cout << "No match found." << std::endl;
    }

    // 使用正则表达式进行替换
    std::string replacedText = std::regex_replace(text, pattern, "Hello, 2022!");

    std::cout << "Replaced text: " << replacedText << std::endl;

    return 0;
}
```

在上述示例中，我们使用正则表达式模式 `"Hello, \\d{4}!"` 来匹配字符串 `"Hello, 2021!"`。`\\d{4}` 表示匹配四位数字。使用 `std::regex_match` 函数进行匹配，如果匹配成功，则输出 "Match found!"。然后，我们使用 `std::regex_replace` 函数将匹配到的部分替换为 "Hello, 2022!"，并输出替换后的文本。

C++11 正则表达式提供了强大的功能，支持正则表达式的匹配、搜索和替换等操作，可以用于字符串处理、文本解析和模式匹配等场景。有关更详细的用法和正则表达式语法，请参考 C++ 文档中有关正则表达式的部分。

#### 2.1.11 lambda 表达式

在 C++11 中引入了一种方便的编写匿名函数的语法，称为 lambda 表达式。lambda 表达式允许我们在需要函数对象的地方内联定义和使用函数，而无需显式定义命名函数。

lambda 表达式的语法如下：

```cpp
[capture list] (parameters) -> return type {
    // 函数体
}
```

其中：

- `capture list`（捕获列表）：指定 lambda 表达式访问的外部变量。可以是空列表，表示不捕获任何变量；也可以是 `[var]` 形式，表示捕获单个变量 `var`；还可以是 `[var1, var2, ...]` 形式，表示捕获多个变量。捕获可以按值（默认）或按引用进行。

- `parameters`（参数列表）：指定 lambda 表达式的参数。与普通函数的参数列表相似，可以为空或包含一个或多个参数。

- `return type`（返回类型）：指定 lambda 表达式的返回类型。可以为空，表示返回类型由编译器推断；也可以使用 `auto` 关键字，让编译器自动推断返回类型；还可以显式指定返回类型。

- `{}`（函数体）：包含 lambda 表达式的函数体，类似于普通函数的函数体。

以下是一些 lambda 表达式的示例：

```cpp
#include <iostream>

int main() {
    // lambda 表达式示例 1：无参数，无返回值
    [] {
        std::cout << "Hello, lambda!" << std::endl;
    }();

    // lambda 表达式示例 2：带参数，有返回值
    int sum = [](int a, int b) -> int {
        return a + b;
    }(3, 4);

    std::cout << "Sum: " << sum << std::endl;

    // lambda 表达式示例 3：捕获外部变量
    int x = 5;
    int y = 2;

    auto product = [x, &y]() -> int {
        return x * y;
    };

    std::cout << "Product: " << product() << std::endl;

    return 0;
}
```

在上述示例中，我们定义了三个 lambda 表达式：

1. 第一个 lambda 表达式没有参数，也没有返回值。它直接调用并输出 "Hello, lambda!"。

2. 第二个 lambda 表达式带有两个参数 `a` 和 `b`，返回它们的和。我们在调用时传递了参数 3 和 4，并将结果存储在变量 `sum` 中。

3. 第三个 lambda 表达式捕获了外部变量 `x`（按值捕获）和 `y`（按引用捕获），计算它们的乘积并返回。我们在调用时输出了结果。

lambda 表达式非常有用，特别是在需要定义简单的、临时的函数对象时。它们可以减少代码的复杂性和冗余，并提高代码的可读性和可维护性。